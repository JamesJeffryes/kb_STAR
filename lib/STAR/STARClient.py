# -*- coding: utf-8 -*-
############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
############################################################

from __future__ import print_function
# the following is a hack to get the baseclient to import whether we're in a
# package or not. This makes pep8 unhappy hence the annotations.
try:
    # baseclient and this client are in a package
    from .baseclient import BaseClient as _BaseClient  # @UnusedImport
except:
    # no they aren't
    from baseclient import BaseClient as _BaseClient  # @Reimport


class STAR(object):

    def __init__(
            self, url=None, timeout=30 * 60, user_id=None,
            password=None, token=None, ignore_authrc=False,
            trust_all_ssl_certificates=False,
            auth_svc='https://kbase.us/services/authorization/Sessions/Login'):
        if url is None:
            raise ValueError('A url is required')
        self._service_ver = None
        self._client = _BaseClient(
            url, timeout=timeout, user_id=user_id, password=password,
            token=token, ignore_authrc=ignore_authrc,
            trust_all_ssl_certificates=trust_all_ssl_certificates,
            auth_svc=auth_svc)

    def star_generate_indexes(self, params, context=None):
        """
        The actual function is declared using 'funcdef' to specify the name
        and input/return arguments to the function.  For all typical KBase
        Apps that run in the Narrative, your function should have the 
        'authentication required' modifier.
        :param params: instance of type "GenerateIndexesParams" (Arguments
           for star_generate_indexes string runMode: default: alignReads type
           of the run: alignReads => map reads genomeGenerate => generate
           genome files inputAlignmentsFromBAM => input alignments from BAM.
           Presently only works with -outWigType and -bamRemoveDuplicates.
           liftOver => lift-over of GTF files (-sjdbGTFfile) between genome
           assemblies using chain file(s) from -genomeChainFiles. int
           runThreadN: default: 1 number of threads to run STAR list<string>
           genomeFastaFiles: path(s) to the fasta files with genomic
           sequences for genome generation. Only used if
           runMode==genomeGenerate.These files should be plain text FASTA
           files, they *cannot* be zipped. string sjdbGTFfile: default: -;
           path to the GTF file with annotations int sjdbOverhang: default:
           100; int>0: length of the donor/acceptor sequence on each side of
           the junctions, ideally = (mate length - 1)) -> structure:
           parameter "workspace_name" of String, parameter "runMode" of
           String, parameter "runThreadN" of Long, parameter
           "genomeFastaFiles" of list of String, parameter "sjdbGTFfile" of
           String, parameter "sjdbOverhang" of Long
        :returns: instance of type "STARResults" (Here is the definition of
           the output of the function.  The output can be used by other SDK
           modules which call your code, or the output visualizations in the
           Narrative.  'report_name' and 'report_ref' are special output
           fields- if defined, the Narrative can automatically render your
           Report.) -> structure: parameter "report_name" of String,
           parameter "report_ref" of String
        """
        return self._client.call_method(
            'STAR.star_generate_indexes',
            [params], self._service_ver, context)

    def star_mapping(self, params, context=None):
        """
        The actual function is declared using 'funcdef' to specify the name
        and input/return arguments to the function.  For all typical KBase
        Apps that run in the Narrative, your function should have the 
        'authentication required' modifier.
        :param params: instance of type "MappingParams" (Arguments for
           star_mapping int runThreadN: default: 1 number of threads to run
           STAR list<string> readFilesIn: default: Read1 Read2 paths to files
           that contain input read1 (and, if needed, read2)) -> structure:
           parameter "workspace_name" of String, parameter "runThreadN" of
           Long, parameter "readFilesIn" of list of String
        :returns: instance of type "STARResults" (Here is the definition of
           the output of the function.  The output can be used by other SDK
           modules which call your code, or the output visualizations in the
           Narrative.  'report_name' and 'report_ref' are special output
           fields- if defined, the Narrative can automatically render your
           Report.) -> structure: parameter "report_name" of String,
           parameter "report_ref" of String
        """
        return self._client.call_method(
            'STAR.star_mapping',
            [params], self._service_ver, context)

    def status(self, context=None):
        return self._client.call_method('STAR.status',
                                        [], self._service_ver, context)
